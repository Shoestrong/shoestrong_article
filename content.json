[{"title":"node.js建立个简单的web服务器","date":"2016-11-15T02:09:52.000Z","path":"/template/20161115/node-webserver/","text":"接触nodejs还不算太多，欠缺的知识方面很多。 就来试着搭建一下，废话少说直接上代码： cmd: 123cd ./myServer &lt;自己的文件目录&gt;node server.js &lt;直接node下运行server.js&gt; server.js: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111// 这是一个简单的Node HTTP服务器,能处理当前目录的文件// 并能实现两种特殊的URL用于测试// 用HTTP://localhost:4000或http://127.0.0.1:4000连接这个服务器// 首先加载所有需要用到的模块var http = require('http'); // Http服务器APIvar fs = require('fs'); // 用于处理本地文件var server = new http.Server(); // 创建新的HTTP服务器server.listen(4000); // 监听端口4000// 使用on方法注册时间处理server.on('request', function(request, response) &#123; // 当有request请求的时候触发处理函数 console.log('Request'); // 解析请求的URL var url = require('url').parse(request.url); // 特殊URL会让服务器在发送响应前先等待 switch(url.pathname) &#123; case ''||'/' : // 模拟欢迎页,nodejs是高效流处理的方案,也可以通过配置文件来配置 fs.readFile('./index.html', function(err, content)&#123; if(err) &#123; response.writeHead(404, &#123; 'Content-Type':'text/plain; charset=\"UTF-8\"' &#125;); response.write(err.message); response.end(); &#125; else &#123; response.writeHead(200, &#123; 'Content-Type' : 'text/html; charset=UTF-8' &#125;); response.write(content); response.end(); &#125; &#125;); break; case '/test/delay':// 此处用于模拟缓慢的网络连接 // 使用查询字符串来获取延迟时长,或者2000毫秒 var delay = parseInt(url.query) || 2000; // 设置响应状态和头 response.writeHead(200, &#123;'Content-type':'text/plain; charset=UTF-8'&#125;); // 立即开始编写响应主体 response.write('Sleeping for' + delay + ' milliseconds...'); // 在之后调用的另一个函数中完成响应 setTimeout(function()&#123; response.write('done.'); response.end(); &#125;, delay); break; case '/test/mirror':// 如果请求是test/mirror,则原文返回它 // 响应状态和头 response.writeHead(200, &#123;'Content-type':'text/plain; charset=UTF-8'&#125;); // 用请求的内容开始编写响应主体 response.write(request.mothod + ' ' + request.url + ' HTTP/' + request.httpVersion + '\\r\\n'); // 所有的请求头 for (var h in request.headers) &#123; response.write(h + ':' + request.headers[h] + '\\r\\n'); &#125; response.write('\\r\\n');// 使用额外的空白行来结束头 // 在这些事件处理程序函数中完成响应 // 当请求主体的数据块完成时,把其写入响应中 request.on('data', function(chunk) &#123; response.write(chunk); &#125;); // 当请求结束时,响应也完成 request.on('end', function(chunk)&#123; response.end(); &#125;); break; case '/json' : // 模拟JSON数据返回 // 响应状态和头 response.writeHead(200, &#123;'Content-type':'application/json; charset=UTF-8'&#125;); response.write(JSON.stringify(&#123;test:'success'&#125;)); response.end(); break; default:// 处理来自本地目录的文件 var filename = url.pathname.substring(1); // 去掉前导'/' var type = getType(filename.substring(filename.lastIndexOf('.')+1)); // 异步读取文件,并将内容作为单独的数据模块传给回调函数 // 对于确实很大的文件,使用流API fs.createReadStream()更好 fs.readFile(filename, function(err, content)&#123; if(err) &#123; response.writeHead(404, &#123; 'Content-Type':'text/plain; charset=\"UTF-8\"' &#125;); response.write(err.message); response.end(); &#125; else &#123; response.writeHead(200, &#123; 'Content-Type' : type &#125;); response.write(content); response.end(); &#125; &#125;); break; &#125; &#125;);function getType(endTag)&#123; var type=null; switch(endTag)&#123; case 'html' : case 'htm' : type = 'text/html; charset=UTF-8'; break; case 'js' : type = 'application/javascript; charset=\"UTF-8\"'; break; case 'css' : type = 'text/css; charset=\"UTF-8\"'; break; case 'txt' : type = 'text/plain; charset=\"UTF-8\"'; break; case 'manifest' : type = 'text/cache-manifest; charset=\"UTF-8\"'; break; default : type = 'application/octet-stream'; break; &#125; return type;&#125;//向控制台输出服务启动的信息 console.log('[WebServer][Start] running at http://localhost:4000'); 在localhost:4000预览就OK了。","tags":[{"name":"node","slug":"node","permalink":"http://yoursite.com/tags/node/"},{"name":"server","slug":"server","permalink":"http://yoursite.com/tags/server/"}]},{"title":"搞定git分支","date":"2016-11-10T02:09:52.000Z","path":"/template/20161110/git-master/","text":"查看远程分支 12345678$ git branch -a * br-2.1.2.2 master remotes/origin/HEAD -&gt; origin/master remotes/origin/br-2.1.2.1 remotes/origin/br-2.1.2.2 remotes/origin/br-2.1.3 remotes/origin/master 查看本地分支 123$ git branch -a * br-2.1.2.2 master 创建分支 12345$ git branch test $ git branch * br-2.1.2.2 master test 把分支推到远程分支 1$ git push origin test 切换分支到test 1234567891011121314$ git branch * br-2.1.2.2 master test $ git checkout test M Shoestrong-server/src/main/java/com/taobao/Shoestrong/server/service/cmd/GetCustomerTarCmd.java M Shoestrong-server/src/main/java/com/taobao/Shoestrong/server/util/ServerUtil.java Switched to branch &apos;test&apos; $ git branch br-2.1.2.2 master * test M 表示cong 原来分支（上一次修改没有提交br-2.1.2.2）带过来的修改 删除本地分支 git branch -d xxxxx 12345678910111213141516$ git checkout br-2.1.2.2 M Shoestrong-server/src/main/java/com/taobao/Shoestrong/server/service/cmd/GetCustomerTarCmd.java M Shoestrong-server/src/main/java/com/taobao/Shoestrong/server/util/ServerUtil.java Switched to branch &apos;br-2.1.2.2&apos; $ git br * br-2.1.2.2 master test $ git br -d test Deleted branch test (was 17d28d9). $ git br * br-2.1.2.2 master 查看本地和远程分支 -a。前面带*号的代表你当前工作目录所处的分支 1remotes/origin/HEAD -&gt; origin/master #啥意思呢？ ”在clone完成之后，Git 会自动为你将此远程仓库命名为origin（origin只相当于一个别名，运行git remote –v或者查看.git\\/config可以看到origin的含义），并下载其中所有的数据，建立一个指向它的master 分支的指针，我们用(远程仓库名)\\/(分支名) 这样的形式表示远程分支，所以origin\\/master指向的是一个remote branch（从那个branch我们clone数据到本地）“这个是执行 git remote -v 的结果，看出来origin其实就是远程的git地址的一个别名。 123$ git remote -v origin git@xxxx/Shoestrong.git (fetch) origin git@xxxx/Shoestrong.git (push) 123456789$ git branch -a br-2.1.2.2 master * test remotes/origin/HEAD -&gt; origin/master remotes/origin/br-2.1.2.1 remotes/origin/br-2.1.2.2 remotes/origin/br-2.1.3 remotes/origin/master 删除远程版本 1git push origin :br-1.0.0 删除远程分支 12git branch -r -d origin/branch-name git push origin :branch-name","tags":[{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"}]},{"title":"sublime 编辑器配置和构建检查","date":"2016-09-12T08:50:00.000Z","path":"/template/20160912/sublime-set/","text":"sublime安装配置安装node包 jscs npm install jscs -g jshint npm install jshint -g csscomb npm install csscomb -g csslint npm install csslint -g 安装gem包 scss-lint gem install scss_lint 安装sublime3 Package Control 按下 `ctrl+`` 复制粘贴以下代码 12`import urllib.request,os,hashlib; h = &apos;eb2297e1a458f27d836c04bb0cbaf282&apos; + &apos;d0e7a3098092775ccb37ca9d6b2e4b7d&apos;; pf = &apos;Package Control.sublime-package&apos;; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); by = urllib.request.urlopen( &apos;http://packagecontrol.io/&apos; + pf.replace(&apos; &apos;, &apos;%20&apos;)).read(); dh = hashlib.sha256(by).hexdigest();print(&apos;Error validating download (got %s instead of %s), please try manual install&apos; % (dh, h)) if dh != h else open(os.path.join( ipp, pf), &apos;wb&apos; ).write(by)` 安装sublime3插件 按下 ctrl+shift+p，输入’ip’（Install Package） 输入以下插件的名字，按顺序逐个进行安装： EditorConfig Sass SublimeLinter SublimeLinter-jscs SublimeLinter-jshint SublimeLinter-csslint SublimeLinter-contrib-scss-lint JSFormat CSScomb 插件的配置文件将以下配置文件分别下载后放入项目根目录下： EditorConfig配置文件 JSCS配置文件 JSHint配置文件 注意：全局变量需要手动加到配置文件的globals属性里，例： 12345&#123; &quot;globals&quot;: &#123; &quot;ImageHandle&quot;: true &#125;&#125; CSSLint配置文件 SCSS-Lint配置文件 编辑器及插件设置 sublime3 自身 Preferences-&gt;Setting-User，增加下面两个配置：1234&#123; &quot;translate_tabs_to_spaces&quot;: true, &quot;word_wrap&quot;: true&#125; 点击右下角的Spaces-&gt;Convert Indentation to Spaces可以将文件中的所有tab转换成空格 JSFormat Preferences-&gt;Package Settings-&gt;JSFormat-&gt;Setting-User，下载配置文件覆盖 配置好后格式化的默认快捷键是 ctrl+alt+f SublimeLinter 右键-&gt;SublimeLinter-&gt;Lint Mode，有4种检查模式，建议选择 Load/save 右键-&gt;SublimeLinter-&gt;Mark Style，建议选择 Outline 右键-&gt;SublimeLinter-&gt;Choose Gutter Theme，建议选择 Blueberry-round 右键-&gt;SublimeLinter-&gt;Open User Settings，将linter里面jscs的args改成 [&quot;--verbose&quot;]，将linter里面csslint的ignore改成 &quot;box-model,adjoining-classes,box-sizing,compatible-vendor-prefixes,gradients,text-indent,fallback-colors,star-property-hack,underscore-property-hack,bulletproof-font-face,font-faces,import,regex-selectors,universal-selector,unqualified-attributes,overqualified-elements,duplicate-background-images,floats,font-sizes,ids,important,outline-none,qualified-headings,unique-headings&quot; 当光标处于有错误的代码行时，详细的错误信息会显示在下面的状态栏中 右键-&gt;SublimeLinter可以看到所有的快捷键，其中 ctrl+k, a 可以列出所有错误 CSScomb Preferences-&gt;Package Settings-&gt;CSScomb-&gt;Setting-User，下载配置文件覆盖 配置好后格式化的默认快捷键是 ctrl+shift+c grunt插件在项目中安装grunt插件jscs npm install grunt-jscs --save-dev jshint npm install grunt-contrib-jshint --save-devcsslint npm install grunt-contrib-csslint --save-dev scss-lint npm install grunt-scss-lint --save-dev 插件的配置文件 JSCS 123456789&#123; options: &#123; config: true, verbose: true &#125;, files: &#123; src: [...] &#125;&#125; JSHint 12345678&#123; options: &#123; jshintrc: true &#125;, files: &#123; src: [...] &#125;&#125; CSSLint 12345678&#123; options: &#123; csslintrc: &apos;.csslintrc&apos; &#125;, files: &#123; src: [...] &#125;&#125; SCSS-Lint 12345678&#123; options: &#123; config: &apos;.scss-lint.yml&apos; &#125;, files: &#123; src: [...] &#125;&#125;","tags":[{"name":"sublime","slug":"sublime","permalink":"http://yoursite.com/tags/sublime/"},{"name":"编辑器","slug":"编辑器","permalink":"http://yoursite.com/tags/编辑器/"}]},{"title":"必备的7个JavaScript函数","date":"2016-07-21T16:00:00.000Z","path":"/template/20160722/js-function/","text":"防止高频调用的debounce函数debounce 函数对于那些执行事件驱动的任务来说是必不可少的提高性能的函数。如果你在使用scroll, resize, key*等事件触发执行任务时不使用降频函数，也行你就犯了重大的错误。下面这个降频函数 debounce 能让你的代码变的高效： 12345678910111213141516171819function debounce(func, wait, immediate) &#123; var timeout; return function() &#123; var context = this, args = arguments; var later = function() &#123; timeout = null; if (!immediate) func.apply(context, args); &#125;; var callNow = immediate &amp;&amp; !timeout; clearTimeout(timeout); timeout = setTimeout(later, wait); if (callNow) func.apply(context, args); &#125;;&#125;;var myEfficientFn = debounce(function() &#123; // All the taxing stuff you do&#125;, 250);window.addEventListener(&apos;resize&apos;, myEfficientFn); 这个 debounce 函数在给定的时间间隔内只允许你提供的回调函数执行一次，以此降低它的执行频率。当遇到高频触发的事件时，这样的限制显得尤为重要。 设定时间/频率循环检测函数上面提到的 debounce 函数是借助于某个事件的触发。但有时候并没有这样的事件可用，那我们只能自己写一个函数来每隔一段时间检查一次。 12345678910111213function poll (fn, callback, err, timeout, interval) &#123; var startTime = (new Date()).getTime(); var pi = window.setInterval(function()&#123; if (Math.floor(((new Date).getTime() - startTime) / 1000) &lt;= timeout) &#123; if (fn()) &#123; callback(); &#125; &#125; else &#123; window.clearInterval(pi); err(); &#125; &#125;, interval)&#125; 禁止重复调用、只允许执行一次的once 函数很多时候，我们只希望某种动作只能执行一次，就像是我们使用 onload 来限定只在加载完成时执行一次。下面这个函数就能让你的操作执行一次后就不会再重复执行。 1234567891011121314151617181920function once(fn, context) &#123; var result; return function() &#123; if(fn) &#123; result = fn.apply(context || this, arguments); fn = null; &#125; return result; &#125;;&#125;// Usagevar canOnlyFireOnce = once(function() &#123; console.log(&apos;Fired!&apos;);&#125;);canOnlyFireOnce(); // &quot;Fired!&quot;canOnlyFireOnce(); // nada 获取一个链接的绝对地址 getAbsoluteUrl获取链接的绝对地址并不像你想象的那么简单。下面就是一个非常实用的函数，能根据你输入的相对地址，获取绝对地址：var getAbsoluteUrl = (function() { var a; return function(url) { if(!a) a = document.createElement(&apos;a&apos;); a.href = url; return a.href; }; })(); // UsagegetAbsoluteUrl(‘/something’); // http://www.webhek.com/something 判断一个JavaScript函数是否是系统原生函数 isNative很多第三方js脚本都会在全局变量里引入新的函数，有些甚至会覆盖掉系统的原生函数，下面这个方法就是来检查是不是原生函数的： 1234567891011121314151617181920212223;(function() &#123; var toString = Object.prototype.toString; var fnToString = Function.prototype.toString; var reHostCtor = /^\\[object .+?Constructor\\]$/; var reNative = RegExp(&apos;^&apos; + String(toString) .replace(/[.*+?^$&#123;&#125;()|[\\]\\/\\\\]/g, &apos;\\\\$&amp;&apos;) .replace(/toString|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, &apos;$1.*?&apos;) + &apos;$&apos; ); function isNative(value) &#123; var type = typeof value; return type == &apos;function&apos; ? reNative.test(fnToString.call(value)) : (value &amp;&amp; type == &apos;object&apos; &amp;&amp; reHostCtor.test(toString.call(value))) || false; &#125; module.exports = isNative;&#125;());// UsageisNative(alert); // trueisNative(myCustomFunction); // false 用JavaScript创建新的CSS规则 insertRule有时候我们会使用一个CSS选择器(比如 document.querySelectorAll)来获取一个 NodeList ，然后给它们每个依次修改样式。其实这并不是一种高效的做法，高效的做法是用JavaScript新建一段CSS样式规则： 123456789Sheet = (function() &#123; var style = document.createElement(&apos;style&apos;); style.setAttribute(&apos;media&apos;, &apos;screen&apos;); style.appendChild(document.createTextNode(&apos;&apos;)); document.head.appendChild(style); return function(rule)&#123; style.sheet.insertRule( rule, style.sheet.cssRules.length ); &#125; ;&#125;)();Sheet(&quot;.stats &#123; position: relative ; top: 0px &#125;&quot;) ; 这些做法的效率非常高，在一些场景中，比如使用ajax新加载一段html时，使用上面这个方法，你不需要操作新加载的html内容。 判断网页元素是否具有某种属性和样式 matchesSelector12345678910function matchesSelector(el, selector) &#123; var p = Element.prototype; var f = p.matches || p.webkitMatchesSelector || p.mozMatchesSelector || p.msMatchesSelector || function(s) &#123; return [].indexOf.call(document.querySelectorAll(s), this) !== -1; &#125;; return f.call(el, selector);&#125;// UsagematchesSelector(document.getElementById(&apos;myDiv&apos;), &apos;div.someSelector[some-attribute=true]&apos;)","tags":[{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"}]},{"title":"jQuery.extend扩展","date":"2016-04-01T16:00:00.000Z","path":"/template/20160402/jquery-extend/","text":"jQuery.extend 对jQuery本身的属性和方法进行了扩展、（相当于添加静态方法），也可以扩展对象，是否实行深度拷贝(第一个参数决定).jQuery.fn.extend 对jQuery.fn的属性和方法进行了扩展（相当于添加成员方法） 源码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364jQuery.extend = jQuery.fn.extend = function() &#123; var src, copyIsArray, copy, name, options, clone, target = arguments[0] || &#123;&#125;, // 常见用法 jQuery.extend( obj1, obj2 )，此时，target为arguments[0] i = 1, length = arguments.length, deep = false; // Handle a deep copy situation if ( typeof target === &quot;boolean&quot; ) &#123; // 如果第一个参数为true，即 jQuery.extend( true, obj1, obj2 ); 的情况 deep = target; // 此时target是true target = arguments[1] || &#123;&#125;; // target改为 obj1 // skip the boolean and the target i = 2; &#125; // Handle case when target is a string or something (possible in deep copy) if ( typeof target !== &quot;object&quot; &amp;&amp; !jQuery.isFunction(target) ) &#123; // 处理奇怪的情况，比如 jQuery.extend( &apos;hello&apos; , &#123;nick: &apos;casper&#125;)~~ target = &#123;&#125;; &#125; // extend jQuery itself if only one argument is passed if ( length === i ) &#123; // 处理这种情况 jQuery.extend(obj)，或 jQuery.fn.extend( obj ) target = this; // jQuery.extend时，this指的是jQuery；jQuery.fn.extend时，this指的是jQuery.fn --i; &#125; for ( ; i &lt; length; i++ ) &#123; // Only deal with non-null/undefined values if ( (options = arguments[ i ]) != null ) &#123; // 比如 jQuery.extend( obj1, obj2, obj3, ojb4 )，options则为 obj2、obj3... // Extend the base object for ( name in options ) &#123; src = target[ name ]; copy = options[ name ]; // Prevent never-ending loop if ( target === copy ) &#123; // 防止自引用，不赘述 continue; &#125; // Recurse if we&apos;re merging plain objects or arrays // 如果是深拷贝，且被拷贝的属性值本身是个对象 if ( deep &amp;&amp; copy &amp;&amp; ( jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)) ) ) &#123; if ( copyIsArray ) &#123; // 被拷贝的属性值是个数组 copyIsArray = false; clone = src &amp;&amp; jQuery.isArray(src) ? src : []; &#125; else &#123; 被拷贝的属性值是个plainObject，比如&#123; nick: &apos;casper&apos; &#125; clone = src &amp;&amp; jQuery.isPlainObject(src) ? src : &#123;&#125;; &#125; // Never move original objects, clone them target[ name ] = jQuery.extend( deep, clone, copy ); // 递归~ // Don&apos;t bring in undefined values &#125; else if ( copy !== undefined ) &#123; // 浅拷贝，且属性值不为undefined target[ name ] = copy; &#125; &#125; &#125; &#125; // Return the modified object return target;&#125;;","tags":[{"name":"jQuery","slug":"jQuery","permalink":"http://yoursite.com/tags/jQuery/"}]},{"title":"创建对象的方法与实践","date":"2016-02-09T16:00:00.000Z","path":"/template/20160210/create-object/","text":"创建自变量创建对象最简单的方法，对象字面量。JavaScript总是宣扬自己能够“无中生有”地创建对象——不需要类、不需要模板、不需要原型——“噌”地一下，一个有方法有数据的对象就出现了。 123456var o = &#123; x: 42, y: 3.14, f: function() &#123;&#125;, g: function() &#123;&#125;&#125;; 缺点：如果我们想在其他地方创建一个同类型的对象，就得把这个对象的方法、数据和初始化都复制粘贴过去。我们需要一种能够批量创建同类型对象的方法，而不是只创建一个对象。 工厂函数这种方法来创建一类具有相同结构、接口和实现的对象是最简单的。我们不直接创建一个对象字面量，而是将对象字面量作为函数的返回值，当我们需要多次或多处创建同类型的对象时，只要调用这个函数就行了。 123456789function thing() &#123; return &#123; x: 42, y: 3.14, f: function() &#123;&#125;, g: function() &#123;&#125; &#125;;&#125;var o = thing(); 缺点：它会导致内存膨胀，因为每一个对象都包含了工厂函数的独立副本。理论上我们希望所有对象共享一个工厂函数副本。 原型链JavaScript提供了一种内置的在对象之间共享数据的机制，叫做原型链。当我们访问一个对象的属性时，它会委托某些其他对象来完成这一请求。我们可以利用这一点来修改工厂函数，使它创建的每个对象只包含自己特有的数据，而对其他属性的请求则全部委托给原型链上共有的一个对象。 1234567891011var thingPrototype = &#123; f: function() &#123;&#125;, g: function() &#123;&#125;&#125;;function thing() &#123; var o = Object.create(thingPrototype); o.x = 42; o.y = 3.14; return o;&#125;var o = thing(); 事实上，JavaScript本身就有内置的机制来支持这种通用模式。我们不需要自己创建这个共有的对象（即原型对象），JavaScript会自动为每个函数创建一个原型对象，我们可以把共享数据直接放在这个对象里。 123456789thing.prototype.f = function() &#123;&#125;;thing.prototype.g = function() &#123;&#125;;function thing() &#123; var o = Object.create(thing.prototype); o.x = 42; o.y = 3.14; return o;&#125;var o = thing(); 缺点：会导致重复。上述thing函数的第一行和最后一行在每一个“委托原型的工厂函数”中都会重复一次，几乎没有区别。 ES5我们可以把那些重复的代码抽出来，放进一个自定义函数里。这个函数会创建一个对象，并与其他某个任意函数（参数函数）的原型建立委托(继承)关系，然后我们把新创建的对象作为参数，调用这个函数（参数函数），最后返回这个新的对象。 123456789101112function create(fn) &#123; var o = Object.create(fn.prototype); fn.call(o); return o;&#125;Thing.prototype.f = function() &#123;&#125;;Thing.prototype.g = function() &#123;&#125;;function Thing() &#123; this.x = 42; this.y = 3.14;&#125;var o = create(Thing); 事实上，JavaScript对这种方法也有内置的支持机制。我们定义的这个create函数实际上就是new关键字的一个基本实现，因此我们可以顺手把create换成new。 1234567Thing.prototype.f = function() &#123;&#125;;Thing.prototype.g = function() &#123;&#125;;function Thing() &#123; this.x = 42; this.y = 3.14;&#125;var o = new Thing(); 我们现在抵达的这一站通常被称为ES5类。它通过函数来创建对象，把需要共享的数据委托给原型对象，并使用new关键字来处理重复的逻辑。缺点：冗长又难看，而且在实现继承的时候会更冗长更难看。 ES6JavaScript最新的相关改进是ES6 类，用新语法来实现上述功能要简洁得多。 123456789class Thing &#123; constructor() &#123; this.x = 42; this.y = 3.14; &#125; f() &#123;&#125; g() &#123;&#125;&#125;var o = new Thing(); 比较多年以来，JavaScript开发者们与原型链的关系总是若即若离，纠缠不清。而今天我们最有可能遇到的两种创建对象的方式，一种是强烈依赖原型链的class语法，另一种则是完全不依赖原型链的工厂函数语法。这两种方式在性能上和特点上是不一样的——尽管差别不太大。 性能今天的JavaScript引擎已经经过了大幅度的优化，以至于很难通过JavaScript代码来推断怎样会比较快。关键在于测量方法。然而测量方法有时也会失灵。通常每六周就会有更新的JavaScript引擎发布，而在这之前采取的测量方法，和基于这种测量方法做出的决策都有可能失去意义。因此，我的经验法则是选择最官方、最广泛使用的语法，因为大多数时候它经历的实践检验最多，因而性能是最高的。目前来说class语法最符合这一点，在我写这篇文章时，class语法大约比返回字面量的工厂函数快3倍。 特点随着ES6的发布，类与工厂函数之间曾经存在的几点差异消失了。现在，工厂函数和类都能够强制实现真正的私有数据——工厂函数通过闭包实现，类通过WeakMap实现。两者都能实现多重继承——工厂函数可以将其他属性混入自己的对象，类也可以将其他属性混入自己的原型，或者通过类工厂，通过代理也能实现。工厂函数和类也都可以在需要的时候返回任意对象，语法也都很简单。结论综合考虑，我更倾向于class语法。它标准、简单、干净、快速，还提供了所有曾经只有函数工厂才具备的特点。","tags":[{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"}]},{"title":"jquery 小片段","date":"2015-12-22T16:00:00.000Z","path":"/template/20151223/jquery-bits/","text":"检测IE浏览器12345$(document).ready(function() &#123; if(navigator.userAgent.match(/msie/i)) &#123; alert(&apos;I am an old fashioned Internet Explorer&apos;); &#125;&#125;); 平滑滚动至页面顶部123456$(&quot;a[href=&apos;#top&apos;]&quot;).click(function() &#123; $(&quot;html, body&quot;).animate(&#123; scrollTop: 0 &#125;, &quot;slow&quot;); return false;&#125;); 保持始终处于顶部1234567891011121314151617181920$(function() &#123;var $win = $(window);var $nav = $(&apos;.mytoolbar&apos;);var navTop = $(&apos;.mytoolbar&apos;).length &amp;&amp; $(&apos;.mytoolbar&apos;).offset().top;var isFixed = 0;processScroll()$win.on(&apos;scroll&apos;, processScroll)function processScroll() &#123; var i, scrollTop = $win.scrollTop() if(scrollTop &gt;= navTop &amp;&amp; !isFixed) &#123; isFixed = 1 $nav.addClass(&apos;subnav-fixed&apos;) &#125; else if(scrollTop &lt;= navTop &amp;&amp; isFixed) &#123; isFixed = 0 $nav.removeClass(&apos;subnav-fixed&apos;) &#125;&#125;&#125;) 替换html标签123$(&apos;li&apos;).replaceWith(function() &#123; return $(&quot;&lt;div /&gt;&quot;).append($(this).contents());&#125;); 检测小屏幕宽度12345var responsive_viewport = $(window).width();/* 如果小于 481px */if(responsive_viewport &lt; 481) &#123; alert(&apos;屏幕小于481px&apos;);&#125; /* 属于小屏 */ 自动修复损坏图片123$(&apos;img&apos;).error(function() &#123; $(this).attr(&apos;src&apos;, &apos;img/broken.png&apos;);&#125;); 检测复制、 粘贴与剪切操作123456789$(&quot;#textA&quot;).bind(&apos;copy&apos;, function() &#123; $(&apos;span&apos;).text(&apos;copy behaviour detected!&apos;)&#125;);$(&quot;#textA&quot;).bind(&apos;paste&apos;, function() &#123; $(&apos;span&apos;).text(&apos;paste behaviour detected!&apos;)&#125;);$(&quot;#textA&quot;).bind(&apos;cut&apos;, function() &#123; $(&apos;span&apos;).text(&apos;cut behaviour detected!&apos;)&#125;); 自动为外部链接添加target = “blank” 属性1234var root = location.protocol + &apos;//&apos; + location.host;$(&apos;a&apos;).not(&apos;:contains(root)&apos;).click(function() &#123; this.target = &quot;_blank&quot;;&#125;); 悬停时淡入 / 淡出12345678$(document).ready(function() &#123; $(&quot;.thumbs img&quot;).fadeTo(&quot;slow&quot;, 0.6); // This sets the opacity of the thumbs to fade down to 60% when the page loads $(&quot;.thumbs img&quot;).hover(function() &#123; $(this).fadeTo(&quot;slow&quot;, 1.0); // This should set the opacity to 100% on hover &#125;, function() &#123; $(this).fadeTo(&quot;slow&quot;, 0.6); // This should set the opacity back to 60% on mouseout &#125;);&#125;); 禁用文本 / 密码输入中的空格12345$(&apos;input.nospace&apos;).keydown(function(e) &#123; if(e.keyCode == 32) &#123; return false; &#125;&#125;);","tags":[{"name":"jquery","slug":"jquery","permalink":"http://yoursite.com/tags/jquery/"}]},{"title":"jquery留着以后用","date":"2015-11-01T16:00:00.000Z","path":"/template/20151102/jquery-nature/","text":"1. 如何创建嵌套的过滤器 //允许你减少集合中的匹配元素的过滤器， //只剩下那些与给定的选择器匹配的部分。在这种情况下， //查询删除了任何没（:not）有（:has） //包含class为“selected”（.selected）的子节点。 .filter(&quot;:not(:has(.selected))&quot;) 2. 如何重用元素搜索 var allItems = $(&quot;div.item&quot;); var keepList = $(&quot;div#container1 div.item&quot;); //现在你可以继续使用这些jQuery对象来工作了。例如， //基于复选框裁剪“keep list”，复选框的名称 //符合 &lt;DIV&gt;class names: $(formToLookAt + &quot; input:checked&quot;).each(function () { keepList = keepList.filter(&quot;.&quot; + $(this).attr(&quot;name&quot;)); }); &lt;/DIV&gt; 3. 任何使用has()来检查某个元素是否包含某个类或是元素 //jQuery 1.4.*包含了对这一has方法的支持。该方法找出 //某个元素是否包含了其他另一个元素类或是其他任何的 //你正在查找并要在其之上进行操作的东东。 $(&quot;input&quot;).has(&quot;.email&quot;).addClass(&quot;email_icon&quot;); 4. 如何使用jQuery来切换样式表 //找出你希望切换的媒体类型（media-type），然后把href设置成新的样式表。 $('link[media=&quot;screen&quot;]').attr('href','Alternative.css'); 5. 如何限制选择范围（基于优化目的） //尽可能使用标签名来作为类名的前缀， //这样jQuery就不需要花费更多的时间来搜索 //你想要的元素。还要记住的一点是， //针对于你的页面上的元素的操作越具体化， //就越能降低执行和搜索的时间。 var in_stock = $('#shopping_cart_items input.is_in_stock'); &lt;ul id=&quot;shopping_cart_items&quot;&gt; &lt;li&gt;&lt;input type=&quot;radio&quot; value=&quot;Item-X&quot; name=&quot;item&quot; class=&quot;is_in_stock&quot; /&gt;Item X&lt;/li&gt; &lt;li&gt;&lt;input type=&quot;radio&quot; value=&quot;Item-Y&quot; name=&quot;item&quot; class=&quot;3-5_days&quot; /&gt;Item Y&lt;/li&gt; &lt;li&gt;&lt;input type=&quot;radio&quot; value=&quot;Item-Z&quot; name=&quot;item&quot; class=&quot;unknown&quot; /&gt;Item Z&lt;/li&gt; &lt;/ul&gt; 6. 如何正确地使用ToggleClass //切换（toggle）类允许你根据某个类的 //是否存在来添加或是删除该类。 //这种情况下有些开发者使用： a.hasClass('blueButton') ? a.removeClass('blueButton') : a.addClass('blueButton'); //toggleClass允许你使用下面的语句来很容易地做到这一点 a.toggleClass('blueButton'); 7. 如何设置IE特有的功能 if($.browser.msie) {// Internet Explorer其实不那么好用 } 8. 如何使用jQuery来代替一个元素 $('#thatdiv').replaceWith('fnuh'); 9. 如何验证某个元素是否为空 if($('#keks').html().trim()) {//什么都没有找到; } 10. 如何从一个未排序的集合中找出某个元素的索引号 $(&quot;ul &gt; li&quot;).click(function () { var index = $(this).prevAll().length; }); 11. 如何把函数绑定到事件上 $('#foo').bind('click', function () { alert('User clicked on &quot;foo.&quot;'); }); 12. 如何追加或是添加html到元素中 $('#lal').append('sometext'); 13. 在创建元素时，如何使用对象字面量（literal）来定义属性 vare = $(&quot;&quot;, { href:&quot;#&quot;,class:&quot;a-class another-class&quot;, title:&quot;...&quot;}); 14. 如何使用多个属性来进行过滤 //在使用许多相类似的有着不同类型的input元素时， //这种基于精确度的方法很有用 var elements = $('#someid input[type=sometype][value=somevalue]').get(); 15. 如何使用jQuery来预加载图像 jQuery.preloadImages = function () { for (var i = 0; i &lt; arguments.length; i++) { $(&quot;&lt;img /&gt;&quot;).attr('src', arguments[i]); } }; //用法$.preloadImages('image1.gif','/path/to/image2.png','some/image3.jpg'); 16. 如何为任何与选择器相匹配的元素设置事件处理程序 $('button.someClass').live('click', someFunction); //注意，在jQuery 1.4.2中，delegate和undelegate选项 //被引入代替live，因为它们提供了更好的上下文支持 //例如，就table来说，以前你会用 //.live() $(&quot;table&quot;).each(function () { $(&quot;td&quot;, this).live(&quot;hover&quot;, function () { $(this).toggleClass(&quot;hover&quot;); }); }); //现在用 $(&quot;table&quot;).delegate(&quot;td&quot;, &quot;hover&quot;, function () { $(this).toggleClass(&quot;hover&quot;); }); 17. 如何找到一个已经被选中的option元素 $('#someElement').find('option:selected'); 18. 如何隐藏一个包含了某个值文本的元素 $(&quot;p.value:contains('thetextvalue')&quot;).hide(); 19. 如果自动滚动到页面中的某区域 jQuery.fn.autoscroll =function(selector) { $('html,body').animate( { scrollTop: $(this).offset().top }, 500 ); } //然后像这样来滚动到你希望去到的class/area上。 $('.area_name').autoscroll(); 20. 如何检测各种浏览器 if( $.browser.safari)//检测Safari if($.browser.msie &amp;&amp; $.browser.version &gt; 6 )//检测IE6及之后版本 if($.browser.msie &amp;&amp; $.browser.version &lt;= 6 )//检测IE6及之前版本 if($.browser.mozilla &amp;&amp; $.browser.version &gt;='1.8')//检测FireFox 2及之后版本 21. 如何替换串中的词 varel = $('#id' ); el.html(el.html().replace(/word/ig,'')); 22. 如何禁用右键单击上下文菜单 $(document).bind('contextmenu',function(e) { return false;}); 23. 如何定义一个定制的选择器 $.expr[':'].mycustomselector = function(element, index, meta, stack){ // element- 一个DOM元素 // index – 栈中的当前循环索引 // meta – 有关选择器的元数据 // stack – 要循环的所有元素的栈 // 如果包含了当前元素就返回true // 如果不包含当前元素就返回false }; // 定制选择器的用法： $('.someClasses:test').doSomething(); 24. 如何检查某个元素是否存在 if($('#someDiv').length) {//你妹，终于找到了 } 25. 如何使用jQuery来检测右键和左键的鼠标单击两种情况 $(&quot;#someelement&quot;).live('click', function (e) { if ((!$.browser.msie &amp;&amp; e.button == 0) || ($.browser.msie &amp;&amp; e.button == 1)) { alert(&quot;Left Mouse Button Clicked&quot;); } else if (e.button == 2) { alert(&quot;Right Mouse Button Clicked&quot;); } }); 26. 如何显示或是删除input域中的默认值 //这段代码展示了在用户未输入值时， //如何在文本类型的input域中保留 //一个默认值 $(&quot;.swap&quot;).each(function (i) { wap_val[i] = $(this).val(); $(this).focusin(function () { if ($(this).val() == swap_val[i]) { $(this).val(&quot;&quot;); } }).focusout(function () { if ($.trim($(this).val()) == &quot;&quot;) { $(this).val(swap_val[i]); } }); }); 27. 如何在一段时间之后自动隐藏或关闭元素（支持1.4版本） //这是1.3.2中我们使用setTimeout来实现的方式 setTimeout(function () { $('.mydiv').hide('blind', {}, 500) }, 5000); //而这是在1.4中可以使用delay()这一功能来实现的方式（这很像是休眠） $(&quot;.mydiv&quot;).delay(5000).hide('blind', {}, 500); 28. 如何把已创建的元素动态地添加到DOM中 varnewDiv = $(''); newDiv.attr('id','myNewDiv').appendTo('body'); 29. 如何限制“Text-Area”域中的字符的个数 jQuery.fn.maxLength = function (max) { this.each(function () { var type = this.tagName.toLowerCase(); var inputType = this.type ? this.type.toLowerCase() : null; if (type == &quot;input&quot; &amp;&amp; inputType == &quot;text&quot; || inputType == &quot;password&quot;) { this.maxLength = max; } else if (type == &quot;textarea&quot;) { this.onkeypress = function (e) { var ob = e || event; var keyCode = ob.keyCode; var hasSelection = document.selection ? document.selection.createRange().text.length &gt; 0 : this.selectionStart != this.selectionEnd; return !(this.value.length &gt;= max &amp;&amp; (keyCode &gt; 50 || keyCode == 32 || keyCode == 0 || keyCode == 13) &amp;&amp; !ob.ctrlKey &amp;&amp; !ob.altKey &amp;&amp; !hasSelection); }; this.onkeyup = function () { if (this.value.length &gt; max) { this.value = this.value.substring(0, max); } }; } }); }; //用法$('#mytextarea').maxLength(500); 30. 如何为函数创建一个基本的测试 //把测试单独放在模块中 module(&quot;Module B&quot;); test(&quot;some other test&quot;, function () { //指明测试内部预期有多少要运行的断言 expect(2); //一个比较断言，相当于JUnit的assertEquals equals(true, false, &quot;failing test&quot;); equals(true, true, &quot;passing test&quot;); }); 31. 如何在jQuery中克隆一个元素 varcloned = $('#somediv').clone(); 32. 在jQuery中如何测试某个元素是否可见 if($(element).is(':visible')) {//该元素是可见的 } 33. 如何把一个元素放在屏幕的中心位置 jQuery.fn.center = function () { this.css('position', 'absolute'); this.css('top', ($(window).height() - this.height()) / +$(window).scrollTop() + 'px'); this.css('left', ($(window).width() - this.width()) / 2 + $(window).scrollLeft() + 'px'); return this; } //这样来使用上面的函数：$(element).center(); 34. 如何把有着某个特定名称的所有元素的值都放到一个数组中 vararrInputValues =newArray(); $(&quot;input[name='table[]']&quot;).each(function() { arrInputValues.push($(this).val()); }); 35. 如何从元素中除去HTML (function ($) { $.fn.stripHtml = function () { var regexp = /&lt;(&quot;[^&quot;]*&quot;|'[^']*'|[^'&quot;&gt;])*&gt;/gi; this.each(function () { $(this).html($(this).html().replace(regexp, &quot;&quot;)); }); return $(this); } })(jQuery); //用法：$('p').stripHtml(); 36. 如何使用closest来取得父元素 $('#searchBox').closest('div'); 37. 如何使用Firebug和Firefox来记录jQuery事件日志 // 允许链式日志记录 // 用法： $('#someDiv').hide().log('div hidden').addClass('someClass'); jQuery.log = jQuery.fn.log = function (msg) { if (console) { console.log(&quot;%s: %o&quot;, msg, this); } return this; }; 38. 如何强制在弹出窗口中打开链接 jQuery('a.popup').live('click', function () { newwindow = window.open($(this).attr('href'), '', 'height=200,width=150'); if (window.focus) { newwindow.focus(); } return false; }); 39. 如何强制在新的选项卡中打开链接 jQuery('a.newTab').live('click', function () { newwindow = window.open($(this).href); jQuery(this).target = &quot;_blank&quot;; return false; }); 40. 在jQuery中如何使用.siblings()来选择同辈元素 // 不这样做 $('#nav li').click(function () { $('#nav li').removeClass('active'); $(this).addClass('active'); }); //替代做法是 $('#nav li').click(function () { $(this).addClass('active').siblings().removeClass('active'); }); 41. 如何切换页面上的所有复选框 vartog =false;// 或者为true，如果它们在加载时为被选中状态的话 $('a').click(function () { $(&quot;input[type=checkbox]&quot;).attr(&quot;checked&quot;, !tog); tog = !tog; }); 42. 如何基于一些输入文本来过滤一个元素列表 //如果元素的值和输入的文本相匹配的话 //该元素将被返回 $('.someClass').filter(function () { return $(this).attr('value') == $('input#someId').val(); }) 43. 如何获得鼠标垫光标位置x和y $(document).ready(function () { $(document).mousemove(function (e) { $('#XY').html(&quot;X Axis : &quot; + e.pageX + &quot; | Y Axis &quot; + e.pageY); }); }); 44. 如何把整个的列表元素（List Element，LI）变成可点击的 $(&quot;ul li&quot;).click(function () { window.location = $(this).find(&quot;a&quot;).attr(&quot;href&quot;); return false; }); &lt;ul&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Link 1&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Link 2&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Link 3&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Link 4&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; 45. 如何使用jQuery来解析XML（基本的例子） function parseXml(xml) { //找到每个Tutorial并打印出author $(xml).find(&quot;Tutorial&quot;).each(function () { $(&quot;#output&quot;).append($(this).attr(&quot;author&quot;) + &quot;&quot;); }); } 46. 如何检查图像是否已经被完全加载进来 $('#theImage').attr('src', 'image.jpg').load(function () { alert('This Image Has Been Loaded'); }); 47. 如何使用jQuery来为事件指定命名空间 //事件可以这样绑定命名空间 $('input').bind('blur.validation', function (e) { // ... }); //data方法也接受命名空间 $('input').data('validation.isValid', true); 48. 如何检查cookie是否启用 var dt = new Date(); dt.setSeconds(dt.getSeconds() + 60); document.cookie = &quot;cookietest=1; expires=&quot; + dt.toGMTString(); var cookiesEnabled = document.cookie.indexOf(&quot;cookietest=&quot;) != -1; if (!cookiesEnabled) { //没有启用cookie } 49. 如何让cookie过期 var date = new Date(); date.setTime(date.getTime() + (x * 60 * 1000)); $.cookie('example', 'foo', { expires: date }); 50. 如何使用一个可点击的链接来替换页面中任何的URL $.fn.replaceUrl = function () { var regexp = /((ftp|http|https):\\/\\/(\\w+:{0,1}\\w*@)?(\\S+)(:[0-9]+)?(\\/|\\/([\\w#!:.?+=&amp;%@!\\-\\/]))?)/gi; this.each(function () { $(this).html( $(this).html().replace(regexp, '&lt;a href=&quot;$1&quot;&gt;$1&lt;/a&gt;') ); }); return $(this); } //用法 $('p').replaceUrl();","tags":[{"name":"jquery","slug":"jquery","permalink":"http://yoursite.com/tags/jquery/"}]}]